{Module RippleVM
  {Import RippleVM/Registers as Registers from "./registers.syma" open}
  {Import RippleVM/RAM as RAM from "./ram.syma" open}
  {Import Core/Plumb as Plumb open macro}
  {Import Core/Main as CoreMain open}
  {Program
      {State
          Starting
          {InitRegisters}
          {Ops
            {0 0  7  7  14}  // LI A0, 7;
            {1 0  10 8  14}  // LI A1, 8;
            {2 8  7  9  2}   // Sub A2, A1, A0;
            {3 50 9  9  10}  // ADDI A2, A2, 50;
            {4 7  0  9  18}  // STOR A2, R0, A0; // Store A2 at address in R0 + cell offset A0
            {5 7  0  10 17}  // LOAD A3, R0, A0; // Load A0 from address in R0 + cell offset A0
            {6 0  0  0  0}   // HALT
          }
          {InitRam}
      }
      {App}
  }

/*
#define OP_HALT 0
#define OP_NOP  0 // TODO: Make some real code

#define OP_ADD  0x1
#define OP_SUB  0x2
#define OP_AND  0x3
#define OP_OR   0x4
#define OP_XOR  0x5
#define OP_SL   0x6 // Bit Shift Left
#define OP_SR   0x7 // Bit Shift Right
#define OP_SLT  0x8 // Set Less Than signed
#define OP_SLTU 0x9 // Set Less Than unsigned

#define OP_ADDI 0xA
#define OP_ANDI 0xB
#define OP_ORI  0xC
#define OP_XORI 0xD
#define OP_LI   0xE
#define OP_SLLI 0xF
#define OP_SRLI 0x10

#define OP_LOAD 0x11
#define OP_STOR 0x12

#define OP_JAL  0x13
#define OP_JALR 0x14

#define OP_BEQ  0x15
#define OP_BNE  0x16
#define OP_BLT  0x17
#define OP_BGE  0x18

#define OP_BRK  0x19

#define OP_MUL  0x1A
#define OP_DIV  0x1B
#define OP_MOD  0x1C

#define OP_MULI  0x1D
#define OP_DIVI  0x1E
#define OP_MODI  0x1F
*/

  {Rules

    {R Start
      {Plumb {State Starting s... {RAM r...} other...}}
      {PlumbEnd {State Running s... {RAM r...} other...}}
    }

    {R Running->Fetch
      {Plumb {State Running s...}}
      {PlumbEnd {State Fetch s...}}
    }

    {R Fetch->Decode
      {Plumb {State Fetch {Registers p... {reg_ PC pc_} n...} {Ops po... {pc_ op...} no...} other...}}
      {PlumbEnd {State Decode {Op {pc_ op...}} {Registers p... {reg_ PC {Add pc_ 1}} n...} {Ops po... {pc_ op...} no...} other...}}
    }

    {R Decode->Decoding
      {Plumb {State Decode {Op op...} r...}}
      {PlumbEnd {State Decoding {Op op...} r...}}
    }

    // ======= Instruction Decoding =======

    {R Decoding/HALT
      {Plumb {State Decoding {Op {_ op2_ op1_ op0_ opcode_}} r...}}
      {PlumbEnd {State Halt r...}}
      :guard Eq(opcode_, 0) // HALT
    }

    {OpTwoReg Add  1 a_ b_ -> {Mod {Add a_ b_} 65536}}
    {OpTwoReg Sub  2 a_ b_ -> {Mod {Add {Sub a_ b_} 65536} 65536}}
    {OpTwoReg And  3 a_ b_ -> {BitAnd a_ b_}}
    {OpTwoReg Or   4 a_ b_ -> {BitOr a_ b_}}
    {OpTwoReg Xor  5 a_ b_ -> {BitXor a_ b_}}
    {OpTwoReg Sl   6 a_ b_ -> {BitSl a_ b_}}
    {OpTwoReg Sr   7 a_ b_ -> {BitSr a_ b_}}
    {OpTwoReg Slt  8 a_ b_ -> {SetLessThan a_ b_}}
    {OpTwoReg Sltu 9 a_ b_ -> {SetLessThanUnsigned a_ b_}}

    {OpOneReg Addi Add 10}
    {OpOneReg Andi And 11}
    {OpOneReg Ori  Or  12}
    {OpOneReg Xori Xor 13}

    {R Decoding/LI
      {Plumb {State Decoding {Op {_ op2_ op1_ op0_ opcode_}} r...}}
      {PlumbEnd {State Execute {ALU} {Current} {Microcode {PutImm op1_ to reg op0_}}  r...}}
      :guard Eq(opcode_, 14) // LI
    }

    {OpOneReg Slli Sl 15}
    {OpOneReg Srli Sr 16}

    {OpTwoRegMem Load  17}
    {OpTwoRegMem Store 18}

    {OpTwoReg Mul 26 a_ b_ -> {Mod {Mul a_ b_} 65536}}
    {OpTwoReg Div 27 a_ b_ -> {Div a_ b_}}
    {OpTwoReg Mod 28 a_ b_ -> {Mod a_ b_}}
    {OpOneReg Muli Mul 29}
    {OpOneReg Divi Div 30}
    {OpOneReg Modi Mod 31}

    // ======= Microcode Execution =======

    {R Execute->Executing
      {Plumb {State Execute {ALU ops...} {Current} {Microcode step_ mc...} r...}}
      {PlumbEnd {State ExecutingMicrocode {ALU ops...} {Current} {Microcode step_ mc...} r...}}
    }

    {R Executing->Microcode/Pick
      {Plumb {State ExecutingMicrocode {ALU ops...} {Current} {Microcode step_ mc...} r...}}
      {PlumbEnd {State ExecutingMicrocode {ALU ops...} {Current step_} {Microcode mc...} r...}}
    }

    // ======= Memory Operations =======
    {R Execute->Microcode/Load
      {Plumb {State ExecutingMicrocode {ALU bank_ addr_} {Current {Load into target_}} mc... {Registers p... {target_ rname_ _} n...} r... {RAM before... {bank_ addr_ v_} after...} rr... }}
      {PlumbEnd {State ExecutingMicrocode {ALU} {Current} mc... {Registers p... {target_ rname_ v_} n...} r... {RAM before... {bank_ addr_ v_} after...} rr... }}
    }

    {R Execute->Microcode/Store
      {Plumb {State ExecutingMicrocode {ALU bank_ addr_} {Current {Store into v_}} mc... {RAM before... {bank_ addr_ _} after...} r...}}
      {PlumbEnd {State ExecutingMicrocode {ALU} {Current} mc... {RAM before... {bank_ addr_ v_} after...} r...}}
    }

    // ======= Helpers =======

    {R Execute->Microcode/LoadImm
      {Plumb {State ExecutingMicrocode {ALU ops...} {Current {LoadImm imm_}} mc... r...}}
      {PlumbEnd {State ExecutingMicrocode {ALU ops... imm_} {Current} mc... r...}}
    }

    {R Execute->Microcode/PutImm
      {Plumb {State ExecutingMicrocode {ALU} {Current {PutImm imm_ to reg reg_}} mc... {Registers p... {reg_ rname_ _} n...} r...}}
      {PlumbEnd {State ExecutingMicrocode {ALU} {Current} mc... {Registers p... {reg_ rname_ imm_} n...} r...}}
    }

    {R Execute->Microcode/LoadReg
      {Plumb {State ExecutingMicrocode {ALU ops...} {Current {LoadReg reg_}} mc... {Registers p... {reg_ rname_ v_} n...} r...}}
      {PlumbEnd {State ExecutingMicrocode {ALU ops... v_} {Current} mc... {Registers p... {reg_ rname_ v_} n...} r...}}
    }

    // ======= Microcode Completion =======

    {R Execute->Microcode/End
      {Plumb {State ExecutingMicrocode {ALU} {Current} {Microcode} r...}}
      {PlumbEnd {State Fetch r...}}
    }
  }

  {RuleRules
    {R Transform/OpTwoRegs
      {OpTwoReg OPNAME_ OPCODE_ a_ b_ -> EXPR_}
      {Splat
        {R Concat("Decoding/", ToString(OPNAME_))
          {Plumb    {State Decoding {Op {_ op2_ op1_ op0_ opcode_}} r...}}
          {PlumbEnd {State Execute  {ALU} {Current} {Microcode {LoadReg op1_} {LoadReg op2_} {OPNAME_ into op0_}}  r...}}
          :guard Eq(opcode_, OPCODE_)
        }
        {R Concat("Executing/Microcode->", ToString(OPNAME_))
          {Plumb    {State ExecutingMicrocode {ALU a_ b_} {Current {OPNAME_ into op0_}} mc... {Registers p... {op0_ rname_ _}     n...} r...}}
          {PlumbEnd {State ExecutingMicrocode {ALU}       {Current}                     mc... {Registers p... {op0_ rname_ EXPR_} n...} r...}}
        }
      }
    }
    {R Transform/OpTwoRegMem
      {OpTwoRegMem OPNAME_ OPCODE_}
      {Splat
        {R Concat("Decoding/", ToString(OPNAME_))
          {Plumb    {State Decoding {Op {_ op2_ op1_ op0_ opcode_}} r...}}
          {PlumbEnd {State Execute  {ALU} {Current} {Microcode {LoadReg op1_} {LoadReg op2_} {OPNAME_ into op0_}}  r...}}
          :guard Eq(opcode_, OPCODE_)
        }
      }
    }
    {R Transform/OpOneReg
      {OpOneReg OPNAME_ OP_ OPCODE_}
      {R Concat("Decoding/", ToString(OPNAME_))
        {Plumb    {State Decoding {Op {_ op2_ op1_ op0_ opcode_}} r...}}
        {PlumbEnd {State Execute  {ALU} {Current} {Microcode {LoadReg op1_} {LoadImm op2_} {OP_ into op0_}}  r...}}
        :guard Eq(opcode_, OPCODE_)
      }
    }
  }
}
