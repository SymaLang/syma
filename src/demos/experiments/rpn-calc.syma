{Module ComputePolish
  {Rules
    {R Compute/Entry {ComputePolish s_} {Compute Start s_}}
    {R Compute/Start {Compute Start s_} {Compute Parsing Split(" ", s_)}}
    {R Compute/Parsed {Compute Parsing {Strings s...}} {Compute Interpreting {Result} {Stack} {Current} {Strings s...}}}

    {R Compute/Interpreting/Take
        {Compute Interpreting {Result} {Stack ops...} {Current} {Strings op_ s...}}
        {Compute Interpreting {Result} {Stack ops...} {Current ParseNum(op_)} {Strings s...}}
    }

    {R Compute/Interpreting/Push
        {Compute Interpreting {Result} {Stack ops...} {Current op_} strings...}
        {Compute Interpreting {Result} {Stack ops... op_} {Current} strings...}
        :guard IsNum(Frozen(op_))
    }

    {R Compute/Interpreting/Calc/Start
        {Compute Interpreting {Result} {Stack ops... a_ b_} {Current op_} strings...}
        {Compute Interpreting {Result} {Stack ops... } {Calc ToOp(op_, a_, b_) } {Current} strings...}
        :guard IsStr(Frozen(op_))
    }

    {R Compute/Interpreting/Calc/Err/InvalidOp
        {Compute Interpreting {Result} {Stack ops...} {Current op_} strings...}
        {Err Concat("Invalid Operation: ", op_)}
        :guard Not(IsValidOp(op_))
    }

    {R Compute/Interpreting/Calc/Err/Underflow
        {Compute Interpreting {Result} {Stack ops...} {Current op_} strings...}
        {Err Concat("Stack Underflow: ", op_)}
        :guard And(IsStr(Frozen(op_)), IsValidOp(op_))
    }

    {R Compute/Interpreting/Calc/ToOp/Plus
        {Compute Interpreting {Result} {Stack ops... } {Calc ToOp(op_, a_, b_) } {Current} strings...}
        {Compute Interpreting {Result} {Stack ops... Add(a_, b_)} {Current} strings...}
        :guard Eq(op_, "+")
    }
    {R Compute/Interpreting/Calc/ToOp/Minus
        {Compute Interpreting {Result} {Stack ops... } {Calc ToOp(op_, a_, b_) } {Current} strings...}
        {Compute Interpreting {Result} {Stack ops... Sub(a_, b_)} {Current} strings...}
        :guard Eq(op_, "-")
    }
    {R Compute/Interpreting/Calc/ToOp/Mul
        {Compute Interpreting {Result} {Stack ops... } {Calc ToOp(op_, a_, b_) } {Current} strings...}
        {Compute Interpreting {Result} {Stack ops... Mul(a_, b_)} {Current} strings...}
        :guard Eq(op_, "*")
    }
    {R Compute/Interpreting/Calc/ToOp/Div
        {Compute Interpreting {Result} {Stack ops... } {Calc ToOp(op_, a_, b_) } {Current} strings...}
        {Compute Interpreting {Result} {Stack ops... Div(a_, b_)} {Current} strings...}
        :guard Eq(op_, "/")
    }

    {R Compute/End {Compute Interpreting {Result} {Stack st... r_} {Current} {Strings}} {Ok r_}}

    {R IsValidOp {IsValidOp op_} Neq({IndexOf "+-*/" op_}, -1)}
  }
}